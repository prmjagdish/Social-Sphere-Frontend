{
  "version": 3,
  "sources": ["../../@eslint/config-helpers/dist/cjs/index.cjs", "../../eslint/lib/config-api.js"],
  "sourcesContent": ["'use strict';\n\n/**\n * @fileoverview defineConfig helper\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"eslint\").Linter.Config} Config */\n/** @typedef {import(\"eslint\").Linter.LegacyConfig} LegacyConfig */\n/** @typedef {import(\"eslint\").ESLint.Plugin} Plugin */\n/** @typedef {import(\"eslint\").Linter.RuleEntry} RuleEntry */\n/** @typedef {import(\"./types.ts\").ExtendsElement} ExtendsElement */\n/** @typedef {import(\"./types.ts\").SimpleExtendsElement} SimpleExtendsElement */\n/** @typedef {import(\"./types.ts\").ConfigWithExtends} ConfigWithExtends */\n/** @typedef {import(\"./types.ts\").InfiniteArray<Config>} InfiniteConfigArray */\n/** @typedef {import(\"./types.ts\").ConfigWithExtendsArray} ConfigWithExtendsArray */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst eslintrcKeys = [\n\t\"env\",\n\t\"extends\",\n\t\"globals\",\n\t\"ignorePatterns\",\n\t\"noInlineConfig\",\n\t\"overrides\",\n\t\"parser\",\n\t\"parserOptions\",\n\t\"reportUnusedDisableDirectives\",\n\t\"root\",\n];\n\nconst allowedGlobalIgnoreKeys = new Set([\"basePath\", \"ignores\", \"name\"]);\n\n/**\n * Gets the name of a config object.\n * @param {Config} config The config object.\n * @param {string} indexPath The index path of the config object.\n * @return {string} The name of the config object.\n */\nfunction getConfigName(config, indexPath) {\n\tif (config.name) {\n\t\treturn config.name;\n\t}\n\n\treturn `UserConfig${indexPath}`;\n}\n\n/**\n * Gets the name of an extension.\n * @param {SimpleExtendsElement} extension The extension.\n * @param {string} indexPath The index of the extension.\n * @return {string} The name of the extension.\n */\nfunction getExtensionName(extension, indexPath) {\n\tif (typeof extension === \"string\") {\n\t\treturn extension;\n\t}\n\n\tif (extension.name) {\n\t\treturn extension.name;\n\t}\n\n\treturn `ExtendedConfig${indexPath}`;\n}\n\n/**\n * Determines if a config object is a legacy config.\n * @param {Config|LegacyConfig} config The config object to check.\n * @return {config is LegacyConfig} `true` if the config object is a legacy config.\n */\nfunction isLegacyConfig(config) {\n\tfor (const key of eslintrcKeys) {\n\t\tif (key in config) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Determines if a config object is a global ignores config.\n * @param {Config} config The config object to check.\n * @return {boolean} `true` if the config object is a global ignores config.\n */\nfunction isGlobalIgnores(config) {\n\treturn Object.keys(config).every(key => allowedGlobalIgnoreKeys.has(key));\n}\n\n/**\n * Parses a plugin member ID (rule, processor, etc.) and returns\n * the namespace and member name.\n * @param {string} id The ID to parse.\n * @returns {{namespace:string, name:string}} The namespace and member name.\n */\nfunction getPluginMember(id) {\n\tconst firstSlashIndex = id.indexOf(\"/\");\n\n\tif (firstSlashIndex === -1) {\n\t\treturn { namespace: \"\", name: id };\n\t}\n\n\tlet namespace = id.slice(0, firstSlashIndex);\n\n\t/*\n\t * Special cases:\n\t * 1. The namespace is `@`, that means it's referring to the\n\t *    core plugin so `@` is the full namespace.\n\t * 2. The namespace starts with `@`, that means it's referring to\n\t *    an npm scoped package. That means the namespace is the scope\n\t *    and the package name (i.e., `@eslint/core`).\n\t */\n\tif (namespace[0] === \"@\" && namespace !== \"@\") {\n\t\tconst secondSlashIndex = id.indexOf(\"/\", firstSlashIndex + 1);\n\t\tif (secondSlashIndex !== -1) {\n\t\t\tnamespace = id.slice(0, secondSlashIndex);\n\t\t\treturn { namespace, name: id.slice(secondSlashIndex + 1) };\n\t\t}\n\t}\n\n\tconst name = id.slice(firstSlashIndex + 1);\n\n\treturn { namespace, name };\n}\n\n/**\n * Normalizes the plugin config by replacing the namespace with the plugin namespace.\n * @param {string} userNamespace The namespace of the plugin.\n * @param {Plugin} plugin The plugin config object.\n * @param {Config} config The config object to normalize.\n * @return {Config} The normalized config object.\n */\nfunction normalizePluginConfig(userNamespace, plugin, config) {\n\tconst pluginNamespace = plugin.meta?.namespace;\n\n\t// don't do anything if the plugin doesn't have a namespace or rules\n\tif (\n\t\t!pluginNamespace ||\n\t\tpluginNamespace === userNamespace ||\n\t\t(!config.rules && !config.processor && !config.language)\n\t) {\n\t\treturn config;\n\t}\n\n\tconst result = { ...config };\n\n\t// update the rules\n\tif (result.rules) {\n\t\tconst ruleIds = Object.keys(result.rules);\n\n\t\t/** @type {Record<string,RuleEntry|undefined>} */\n\t\tconst newRules = {};\n\n\t\tfor (let i = 0; i < ruleIds.length; i++) {\n\t\t\tconst ruleId = ruleIds[i];\n\t\t\tconst { namespace: ruleNamespace, name: ruleName } =\n\t\t\t\tgetPluginMember(ruleId);\n\n\t\t\tif (ruleNamespace === pluginNamespace) {\n\t\t\t\tnewRules[`${userNamespace}/${ruleName}`] = result.rules[ruleId];\n\t\t\t} else {\n\t\t\t\tnewRules[ruleId] = result.rules[ruleId];\n\t\t\t}\n\t\t}\n\n\t\tresult.rules = newRules;\n\t}\n\n\t// update the processor\n\n\tif (typeof result.processor === \"string\") {\n\t\tconst { namespace: processorNamespace, name: processorName } =\n\t\t\tgetPluginMember(result.processor);\n\n\t\tif (processorNamespace) {\n\t\t\tif (processorNamespace === pluginNamespace) {\n\t\t\t\tresult.processor = `${userNamespace}/${processorName}`;\n\t\t\t}\n\t\t}\n\t}\n\n\t// update the language\n\tif (typeof result.language === \"string\") {\n\t\tconst { namespace: languageNamespace, name: languageName } =\n\t\t\tgetPluginMember(result.language);\n\n\t\tif (languageNamespace === pluginNamespace) {\n\t\t\tresult.language = `${userNamespace}/${languageName}`;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Deeply normalizes a plugin config, traversing recursively into an arrays.\n * @param {string} userPluginNamespace The namespace of the plugin.\n * @param {Plugin} plugin The plugin object.\n * @param {Config|LegacyConfig|(Config|LegacyConfig)[]} pluginConfig The plugin config to normalize.\n * @param {string} pluginConfigName The name of the plugin config.\n * @return {InfiniteConfigArray} The normalized plugin config.\n * @throws {TypeError} If the plugin config is a legacy config.\n */\nfunction deepNormalizePluginConfig(\n\tuserPluginNamespace,\n\tplugin,\n\tpluginConfig,\n\tpluginConfigName,\n) {\n\t// if it's an array then it's definitely a new config\n\tif (Array.isArray(pluginConfig)) {\n\t\treturn pluginConfig.map(pluginSubConfig =>\n\t\t\tdeepNormalizePluginConfig(\n\t\t\t\tuserPluginNamespace,\n\t\t\t\tplugin,\n\t\t\t\tpluginSubConfig,\n\t\t\t\tpluginConfigName,\n\t\t\t),\n\t\t);\n\t}\n\n\t// if it's a legacy config, throw an error\n\tif (isLegacyConfig(pluginConfig)) {\n\t\tthrow new TypeError(\n\t\t\t`Plugin config \"${pluginConfigName}\" is an eslintrc config and cannot be used in this context.`,\n\t\t);\n\t}\n\n\treturn normalizePluginConfig(userPluginNamespace, plugin, pluginConfig);\n}\n\n/**\n * Finds a plugin config by name in the given config.\n * @param {Config} config The config object.\n * @param {string} pluginConfigName The name of the plugin config.\n * @return {InfiniteConfigArray} The plugin config.\n * @throws {TypeError} If the plugin config is not found or is a legacy config.\n */\nfunction findPluginConfig(config, pluginConfigName) {\n\tconst { namespace: userPluginNamespace, name: configName } =\n\t\tgetPluginMember(pluginConfigName);\n\tconst plugin = config.plugins?.[userPluginNamespace];\n\n\tif (!plugin) {\n\t\tthrow new TypeError(`Plugin \"${userPluginNamespace}\" not found.`);\n\t}\n\n\tconst directConfig = plugin.configs?.[configName];\n\tif (directConfig) {\n\t\t// Arrays are always flat configs, and non-legacy configs can be used directly\n\t\tif (Array.isArray(directConfig) || !isLegacyConfig(directConfig)) {\n\t\t\treturn deepNormalizePluginConfig(\n\t\t\t\tuserPluginNamespace,\n\t\t\t\tplugin,\n\t\t\t\tdirectConfig,\n\t\t\t\tpluginConfigName,\n\t\t\t);\n\t\t}\n\n\t\t// If it's a legacy config, look for the flat version\n\t\tconst flatConfig = plugin.configs?.[`flat/${configName}`];\n\n\t\tif (\n\t\t\tflatConfig &&\n\t\t\t(Array.isArray(flatConfig) || !isLegacyConfig(flatConfig))\n\t\t) {\n\t\t\treturn deepNormalizePluginConfig(\n\t\t\t\tuserPluginNamespace,\n\t\t\t\tplugin,\n\t\t\t\tflatConfig,\n\t\t\t\tpluginConfigName,\n\t\t\t);\n\t\t}\n\n\t\tthrow new TypeError(\n\t\t\t`Plugin config \"${configName}\" in plugin \"${userPluginNamespace}\" is an eslintrc config and cannot be used in this context.`,\n\t\t);\n\t}\n\n\tthrow new TypeError(\n\t\t`Plugin config \"${configName}\" not found in plugin \"${userPluginNamespace}\".`,\n\t);\n}\n\n/**\n * Flattens an array while keeping track of the index path.\n * @param {any[]} configList The array to traverse.\n * @param {string} indexPath The index path of the value in a multidimensional array.\n * @return {IterableIterator<{indexPath:string, value:any}>} The flattened list of values.\n */\nfunction* flatTraverse(configList, indexPath = \"\") {\n\tfor (let i = 0; i < configList.length; i++) {\n\t\tconst newIndexPath = indexPath ? `${indexPath}[${i}]` : `[${i}]`;\n\n\t\t// if it's an array then traverse it as well\n\t\tif (Array.isArray(configList[i])) {\n\t\t\tyield* flatTraverse(configList[i], newIndexPath);\n\t\t\tcontinue;\n\t\t}\n\n\t\tyield { indexPath: newIndexPath, value: configList[i] };\n\t}\n}\n\n/**\n * Extends a list of config files by creating every combination of base and extension files.\n * @param {(string|string[])[]} [baseFiles] The base files.\n * @param {(string|string[])[]} [extensionFiles] The extension files.\n * @return {(string|string[])[]} The extended files.\n */\nfunction extendConfigFiles(baseFiles = [], extensionFiles = []) {\n\tif (!extensionFiles.length) {\n\t\treturn baseFiles.concat();\n\t}\n\n\tif (!baseFiles.length) {\n\t\treturn extensionFiles.concat();\n\t}\n\n\t/** @type {(string|string[])[]} */\n\tconst result = [];\n\n\tfor (const baseFile of baseFiles) {\n\t\tfor (const extensionFile of extensionFiles) {\n\t\t\t/*\n\t\t\t * Each entry can be a string or array of strings. The end result\n\t\t\t * needs to be an array of strings, so we need to be sure to include\n\t\t\t * all of the items when there's an array.\n\t\t\t */\n\n\t\t\tconst entry = [];\n\n\t\t\tif (Array.isArray(baseFile)) {\n\t\t\t\tentry.push(...baseFile);\n\t\t\t} else {\n\t\t\t\tentry.push(baseFile);\n\t\t\t}\n\n\t\t\tif (Array.isArray(extensionFile)) {\n\t\t\t\tentry.push(...extensionFile);\n\t\t\t} else {\n\t\t\t\tentry.push(extensionFile);\n\t\t\t}\n\n\t\t\tresult.push(entry);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Extends a config object with another config object.\n * @param {Config} baseConfig The base config object.\n * @param {string} baseConfigName The name of the base config object.\n * @param {Config} extension The extension config object.\n * @param {string} extensionName The index of the extension config object.\n * @return {Config} The extended config object.\n */\nfunction extendConfig(baseConfig, baseConfigName, extension, extensionName) {\n\tconst result = { ...extension };\n\n\t// for global ignores there is no further work to be done, we just keep everything\n\tif (!isGlobalIgnores(extension)) {\n\t\t// for files we need to create every combination of base and extension files\n\t\tif (baseConfig.files) {\n\t\t\tresult.files = extendConfigFiles(baseConfig.files, extension.files);\n\t\t}\n\n\t\t// for ignores we just concatenation the extension ignores onto the base ignores\n\t\tif (baseConfig.ignores) {\n\t\t\tresult.ignores = baseConfig.ignores.concat(extension.ignores ?? []);\n\t\t}\n\t}\n\n\tresult.name = `${baseConfigName} > ${extensionName}`;\n\n\t// @ts-ignore -- ESLint types aren't updated yet\n\tif (baseConfig.basePath) {\n\t\t// @ts-ignore -- ESLint types aren't updated yet\n\t\tresult.basePath = baseConfig.basePath;\n\t}\n\n\treturn result;\n}\n\n/**\n * Processes a list of extends elements.\n * @param {ConfigWithExtends} config The config object.\n * @param {WeakMap<Config, string>} configNames The map of config objects to their names.\n * @return {Config[]} The flattened list of config objects.\n * @throws {TypeError} If the `extends` property is not an array or if nested `extends` is found.\n */\nfunction processExtends(config, configNames) {\n\tif (!config.extends) {\n\t\treturn [config];\n\t}\n\n\tif (!Array.isArray(config.extends)) {\n\t\tthrow new TypeError(\"The `extends` property must be an array.\");\n\t}\n\n\tconst {\n\t\t/** @type {Config[]} */\n\t\textends: extendsList,\n\n\t\t/** @type {Config} */\n\t\t...configObject\n\t} = config;\n\n\tconst extensionNames = new WeakMap();\n\n\t// replace strings with the actual configs\n\tconst objectExtends = extendsList.map(extendsElement => {\n\t\tif (typeof extendsElement === \"string\") {\n\t\t\tconst pluginConfig = findPluginConfig(config, extendsElement);\n\n\t\t\t// assign names\n\t\t\tif (Array.isArray(pluginConfig)) {\n\t\t\t\tpluginConfig.forEach((pluginConfigElement, index) => {\n\t\t\t\t\textensionNames.set(\n\t\t\t\t\t\tpluginConfigElement,\n\t\t\t\t\t\t`${extendsElement}[${index}]`,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\textensionNames.set(pluginConfig, extendsElement);\n\t\t\t}\n\n\t\t\treturn pluginConfig;\n\t\t}\n\n\t\treturn /** @type {Config} */ (extendsElement);\n\t});\n\n\tconst result = [];\n\n\tfor (const { indexPath, value: extendsElement } of flatTraverse(\n\t\tobjectExtends,\n\t)) {\n\t\tconst extension = /** @type {Config} */ (extendsElement);\n\n\t\tif (\"basePath\" in extension) {\n\t\t\tthrow new TypeError(\"'basePath' in `extends` is not allowed.\");\n\t\t}\n\n\t\tif (\"extends\" in extension) {\n\t\t\tthrow new TypeError(\"Nested 'extends' is not allowed.\");\n\t\t}\n\n\t\tconst baseConfigName = /** @type {string} */ (configNames.get(config));\n\t\tconst extensionName =\n\t\t\textensionNames.get(extendsElement) ??\n\t\t\tgetExtensionName(extendsElement, indexPath);\n\n\t\tresult.push(\n\t\t\textendConfig(\n\t\t\t\tconfigObject,\n\t\t\t\tbaseConfigName,\n\t\t\t\textension,\n\t\t\t\textensionName,\n\t\t\t),\n\t\t);\n\t}\n\n\t/*\n\t * If the base config object has only `ignores` and `extends`, then\n\t * removing `extends` turns it into a global ignores, which is not what\n\t * we want. So we need to check if the base config object is a global ignores\n\t * and if so, we don't add it to the array.\n\t *\n\t * (The other option would be to add a `files` entry, but that would result\n\t * in a config that didn't actually do anything because there are no\n\t * other keys in the config.)\n\t */\n\tif (!isGlobalIgnores(configObject)) {\n\t\tresult.push(configObject);\n\t}\n\n\treturn result.flat();\n}\n\n/**\n * Processes a list of config objects and arrays.\n * @param {ConfigWithExtends[]} configList The list of config objects and arrays.\n * @param {WeakMap<Config, string>} configNames The map of config objects to their names.\n * @return {Config[]} The flattened list of config objects.\n */\nfunction processConfigList(configList, configNames) {\n\treturn configList.flatMap(config => processExtends(config, configNames));\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Helper function to define a config array.\n * @param {ConfigWithExtendsArray} args The arguments to the function.\n * @returns {Config[]} The config array.\n * @throws {TypeError} If no arguments are provided or if an argument is not an object.\n */\nfunction defineConfig(...args) {\n\tconst configNames = new WeakMap();\n\tconst configs = [];\n\n\tif (args.length === 0) {\n\t\tthrow new TypeError(\"Expected one or more arguments.\");\n\t}\n\n\t// first flatten the list of configs and get the names\n\tfor (const { indexPath, value } of flatTraverse(args)) {\n\t\tif (typeof value !== \"object\" || value === null) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Expected an object but received ${String(value)}.`,\n\t\t\t);\n\t\t}\n\n\t\tconst config = /** @type {ConfigWithExtends} */ (value);\n\n\t\t// save config name for easy reference later\n\t\tconfigNames.set(config, getConfigName(config, indexPath));\n\t\tconfigs.push(config);\n\t}\n\n\treturn processConfigList(configs, configNames);\n}\n\n/**\n * @fileoverview Global ignores helper function.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nlet globalIgnoreCount = 0;\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Creates a global ignores config with the given patterns.\n * @param {string[]} ignorePatterns The ignore patterns.\n * @param {string} [name] The name of the global ignores config.\n * @returns {Config} The global ignores config.\n * @throws {TypeError} If ignorePatterns is not an array or if it is empty.\n */\nfunction globalIgnores(ignorePatterns, name) {\n\tif (!Array.isArray(ignorePatterns)) {\n\t\tthrow new TypeError(\"ignorePatterns must be an array\");\n\t}\n\n\tif (ignorePatterns.length === 0) {\n\t\tthrow new TypeError(\"ignorePatterns must contain at least one pattern\");\n\t}\n\n\tconst id = globalIgnoreCount++;\n\n\treturn {\n\t\tname: name || `globalIgnores ${id}`,\n\t\tignores: ignorePatterns,\n\t};\n}\n\nexports.defineConfig = defineConfig;\nexports.globalIgnores = globalIgnores;\n", "/**\n * @fileoverview exports for config helpers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\nconst { defineConfig, globalIgnores } = require(\"@eslint/config-helpers\");\n\nmodule.exports = {\n\tdefineConfig,\n\tglobalIgnores,\n};\n"],
  "mappings": "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",
  "names": []
}
