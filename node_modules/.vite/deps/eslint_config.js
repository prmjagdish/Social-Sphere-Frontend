import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/@eslint/config-helpers/dist/cjs/index.cjs
var require_cjs = __commonJS({
  "node_modules/@eslint/config-helpers/dist/cjs/index.cjs"(exports) {
    "use strict";
    var eslintrcKeys = [
      "env",
      "extends",
      "globals",
      "ignorePatterns",
      "noInlineConfig",
      "overrides",
      "parser",
      "parserOptions",
      "reportUnusedDisableDirectives",
      "root"
    ];
    var allowedGlobalIgnoreKeys = /* @__PURE__ */ new Set(["basePath", "ignores", "name"]);
    function getConfigName(config, indexPath) {
      if (config.name) {
        return config.name;
      }
      return `UserConfig${indexPath}`;
    }
    function getExtensionName(extension, indexPath) {
      if (typeof extension === "string") {
        return extension;
      }
      if (extension.name) {
        return extension.name;
      }
      return `ExtendedConfig${indexPath}`;
    }
    function isLegacyConfig(config) {
      for (const key of eslintrcKeys) {
        if (key in config) {
          return true;
        }
      }
      return false;
    }
    function isGlobalIgnores(config) {
      return Object.keys(config).every((key) => allowedGlobalIgnoreKeys.has(key));
    }
    function getPluginMember(id) {
      const firstSlashIndex = id.indexOf("/");
      if (firstSlashIndex === -1) {
        return { namespace: "", name: id };
      }
      let namespace = id.slice(0, firstSlashIndex);
      if (namespace[0] === "@" && namespace !== "@") {
        const secondSlashIndex = id.indexOf("/", firstSlashIndex + 1);
        if (secondSlashIndex !== -1) {
          namespace = id.slice(0, secondSlashIndex);
          return { namespace, name: id.slice(secondSlashIndex + 1) };
        }
      }
      const name = id.slice(firstSlashIndex + 1);
      return { namespace, name };
    }
    function normalizePluginConfig(userNamespace, plugin, config) {
      const pluginNamespace = plugin.meta?.namespace;
      if (!pluginNamespace || pluginNamespace === userNamespace || !config.rules && !config.processor && !config.language) {
        return config;
      }
      const result = { ...config };
      if (result.rules) {
        const ruleIds = Object.keys(result.rules);
        const newRules = {};
        for (let i = 0; i < ruleIds.length; i++) {
          const ruleId = ruleIds[i];
          const { namespace: ruleNamespace, name: ruleName } = getPluginMember(ruleId);
          if (ruleNamespace === pluginNamespace) {
            newRules[`${userNamespace}/${ruleName}`] = result.rules[ruleId];
          } else {
            newRules[ruleId] = result.rules[ruleId];
          }
        }
        result.rules = newRules;
      }
      if (typeof result.processor === "string") {
        const { namespace: processorNamespace, name: processorName } = getPluginMember(result.processor);
        if (processorNamespace) {
          if (processorNamespace === pluginNamespace) {
            result.processor = `${userNamespace}/${processorName}`;
          }
        }
      }
      if (typeof result.language === "string") {
        const { namespace: languageNamespace, name: languageName } = getPluginMember(result.language);
        if (languageNamespace === pluginNamespace) {
          result.language = `${userNamespace}/${languageName}`;
        }
      }
      return result;
    }
    function deepNormalizePluginConfig(userPluginNamespace, plugin, pluginConfig, pluginConfigName) {
      if (Array.isArray(pluginConfig)) {
        return pluginConfig.map(
          (pluginSubConfig) => deepNormalizePluginConfig(
            userPluginNamespace,
            plugin,
            pluginSubConfig,
            pluginConfigName
          )
        );
      }
      if (isLegacyConfig(pluginConfig)) {
        throw new TypeError(
          `Plugin config "${pluginConfigName}" is an eslintrc config and cannot be used in this context.`
        );
      }
      return normalizePluginConfig(userPluginNamespace, plugin, pluginConfig);
    }
    function findPluginConfig(config, pluginConfigName) {
      const { namespace: userPluginNamespace, name: configName } = getPluginMember(pluginConfigName);
      const plugin = config.plugins?.[userPluginNamespace];
      if (!plugin) {
        throw new TypeError(`Plugin "${userPluginNamespace}" not found.`);
      }
      const directConfig = plugin.configs?.[configName];
      if (directConfig) {
        if (Array.isArray(directConfig) || !isLegacyConfig(directConfig)) {
          return deepNormalizePluginConfig(
            userPluginNamespace,
            plugin,
            directConfig,
            pluginConfigName
          );
        }
        const flatConfig = plugin.configs?.[`flat/${configName}`];
        if (flatConfig && (Array.isArray(flatConfig) || !isLegacyConfig(flatConfig))) {
          return deepNormalizePluginConfig(
            userPluginNamespace,
            plugin,
            flatConfig,
            pluginConfigName
          );
        }
        throw new TypeError(
          `Plugin config "${configName}" in plugin "${userPluginNamespace}" is an eslintrc config and cannot be used in this context.`
        );
      }
      throw new TypeError(
        `Plugin config "${configName}" not found in plugin "${userPluginNamespace}".`
      );
    }
    function* flatTraverse(configList, indexPath = "") {
      for (let i = 0; i < configList.length; i++) {
        const newIndexPath = indexPath ? `${indexPath}[${i}]` : `[${i}]`;
        if (Array.isArray(configList[i])) {
          yield* flatTraverse(configList[i], newIndexPath);
          continue;
        }
        yield { indexPath: newIndexPath, value: configList[i] };
      }
    }
    function extendConfigFiles(baseFiles = [], extensionFiles = []) {
      if (!extensionFiles.length) {
        return baseFiles.concat();
      }
      if (!baseFiles.length) {
        return extensionFiles.concat();
      }
      const result = [];
      for (const baseFile of baseFiles) {
        for (const extensionFile of extensionFiles) {
          const entry = [];
          if (Array.isArray(baseFile)) {
            entry.push(...baseFile);
          } else {
            entry.push(baseFile);
          }
          if (Array.isArray(extensionFile)) {
            entry.push(...extensionFile);
          } else {
            entry.push(extensionFile);
          }
          result.push(entry);
        }
      }
      return result;
    }
    function extendConfig(baseConfig, baseConfigName, extension, extensionName) {
      const result = { ...extension };
      if (!isGlobalIgnores(extension)) {
        if (baseConfig.files) {
          result.files = extendConfigFiles(baseConfig.files, extension.files);
        }
        if (baseConfig.ignores) {
          result.ignores = baseConfig.ignores.concat(extension.ignores ?? []);
        }
      }
      result.name = `${baseConfigName} > ${extensionName}`;
      if (baseConfig.basePath) {
        result.basePath = baseConfig.basePath;
      }
      return result;
    }
    function processExtends(config, configNames) {
      if (!config.extends) {
        return [config];
      }
      if (!Array.isArray(config.extends)) {
        throw new TypeError("The `extends` property must be an array.");
      }
      const {
        /** @type {Config[]} */
        extends: extendsList,
        /** @type {Config} */
        ...configObject
      } = config;
      const extensionNames = /* @__PURE__ */ new WeakMap();
      const objectExtends = extendsList.map((extendsElement) => {
        if (typeof extendsElement === "string") {
          const pluginConfig = findPluginConfig(config, extendsElement);
          if (Array.isArray(pluginConfig)) {
            pluginConfig.forEach((pluginConfigElement, index) => {
              extensionNames.set(
                pluginConfigElement,
                `${extendsElement}[${index}]`
              );
            });
          } else {
            extensionNames.set(pluginConfig, extendsElement);
          }
          return pluginConfig;
        }
        return (
          /** @type {Config} */
          extendsElement
        );
      });
      const result = [];
      for (const { indexPath, value: extendsElement } of flatTraverse(
        objectExtends
      )) {
        const extension = (
          /** @type {Config} */
          extendsElement
        );
        if ("basePath" in extension) {
          throw new TypeError("'basePath' in `extends` is not allowed.");
        }
        if ("extends" in extension) {
          throw new TypeError("Nested 'extends' is not allowed.");
        }
        const baseConfigName = (
          /** @type {string} */
          configNames.get(config)
        );
        const extensionName = extensionNames.get(extendsElement) ?? getExtensionName(extendsElement, indexPath);
        result.push(
          extendConfig(
            configObject,
            baseConfigName,
            extension,
            extensionName
          )
        );
      }
      if (!isGlobalIgnores(configObject)) {
        result.push(configObject);
      }
      return result.flat();
    }
    function processConfigList(configList, configNames) {
      return configList.flatMap((config) => processExtends(config, configNames));
    }
    function defineConfig(...args) {
      const configNames = /* @__PURE__ */ new WeakMap();
      const configs = [];
      if (args.length === 0) {
        throw new TypeError("Expected one or more arguments.");
      }
      for (const { indexPath, value } of flatTraverse(args)) {
        if (typeof value !== "object" || value === null) {
          throw new TypeError(
            `Expected an object but received ${String(value)}.`
          );
        }
        const config = (
          /** @type {ConfigWithExtends} */
          value
        );
        configNames.set(config, getConfigName(config, indexPath));
        configs.push(config);
      }
      return processConfigList(configs, configNames);
    }
    var globalIgnoreCount = 0;
    function globalIgnores(ignorePatterns, name) {
      if (!Array.isArray(ignorePatterns)) {
        throw new TypeError("ignorePatterns must be an array");
      }
      if (ignorePatterns.length === 0) {
        throw new TypeError("ignorePatterns must contain at least one pattern");
      }
      const id = globalIgnoreCount++;
      return {
        name: name || `globalIgnores ${id}`,
        ignores: ignorePatterns
      };
    }
    exports.defineConfig = defineConfig;
    exports.globalIgnores = globalIgnores;
  }
});

// node_modules/eslint/lib/config-api.js
var require_config_api = __commonJS({
  "node_modules/eslint/lib/config-api.js"(exports, module) {
    var { defineConfig, globalIgnores } = require_cjs();
    module.exports = {
      defineConfig,
      globalIgnores
    };
  }
});
export default require_config_api();
//# sourceMappingURL=eslint_config.js.map
